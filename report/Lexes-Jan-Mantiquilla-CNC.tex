\documentclass{article}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[square,numbers]{natbib}

%%------------------------------------------------
%% Image and Listing code
%%------------------------------------------------
%% Examples for the commands in the document below
%%
%% includecode:
%% \includecode{caption for table of listings}{caption for reader}{filename}
%% - includes a file with code and adds a caption that should describe the code in some detail and a shorter caption for the table of listings
\newcommand{\includecode}[4]{\lstinputlisting[float,floatplacement=H,
caption={[#1]#2}, captionpos=b, frame=single, label={#3}]{#4}}

%% includefigure:
%% \includefigure{label}{short caption}{long caption}{filename}
%% - includes a figure with a given label, a short caption for the table of contents and a longer caption that describes the figure in some detail
\newcommand{\includefigure}[4]{
  \begin{figure}[H]
    \centering
    \includegraphics{#4}
    \captionsetup{width=.8\linewidth}
    \caption[#2]{#3}
    \label{#1}
  \end{figure}
}

%% includescalefigure:
%% \includescalefigure{label}{short caption}{long caption}{scale}{filename}
%% - includes a figure with a given label, a short caption for the table of contents and a longer caption that describes the figure in some detail and a scale factor 'scale'
\newcommand{\includescalefigure}[5]{
  \begin{figure}[H]
    \centering
    \includegraphics[width=#4\linewidth]{#5}
    \captionsetup{width=.8\linewidth}
    \caption[#2]{#3}
    \label{#1}
  \end{figure}
}


%%------------------------------------------------
%% Parameters
%%------------------------------------------------
% Set up the header and footer
\newcommand{\assignmentTitle}{Assignment\ \#2: OpenFlow} % Assignment title
\newcommand{\moduleCode}{CS2031}
\newcommand{\moduleName}{Telecommunications\ II}
\newcommand{\authorName}{Lexes\ Jan\ Mantiquilla} % Your name
\newcommand{\authorID}{-1} % Your student ID


\title{\textbf{\moduleCode\ \moduleName\ \assignmentTitle}}
\author{\authorName\ -\ \authorID}
\bibliographystyle{abbrvnat}
% Fix url
\Urlmuskip=0mu plus 1mu
\graphicspath{{images/}}

%%------------------------------------------------
%% Document
%%------------------------------------------------
\begin{document}
\captionsetup{width=.8\linewidth}

\maketitle
\tableofcontents

\newpage

\section{Introduction}

\subsection{Problem Statement}

\subsection{Approach}

\section{Overall Design}

\subsection{Problem Statement}

\subsection{Features}

\subsection{OpenFlow}

\subsection{Design of the Protocol}

\subsection{Packet Descriptions}

\section{Implementation}
This section contains an explanation of the implementation. It will describe how
each of the classes used implement the design described above.

\subsection{Packet Classes}
The packet classes are encoded using the method ObejectInputStream and
ByteArrayInputStream. This allows us to create a byte array which is then used
to create a DatagramPacket. The abstract class PacketContent and the classes
which inherit it abstract the creation of DatagramPackets. The abstract
methods toByteArray and fromDatagramPacket do the encoding of the
DatagramPacket. Each implementation of the PacketContent class has their own
implementation of the abstract methods toByteArray and fromDatagramPacket. The
abstract PacketContent abstract class and the AckPacketContent class have been
provided to us in the Advanced sample code. I have created other packet classes
which implement the PacketContent abstract class.

\subsubsection{FeatureRequestPacketContent}
This class is used to create a packet which represents a feature request
packet. The feature request packet is sent by the \textbf{Controller} to a
switch upon receiving a Hello packet. The feature request packet does not
contain any data and only contains its type.

\subsubsection{FeatureResultPacketContent}
This class is used to create a packet which represents a feature result packet.
The feature result packet is sent by the \textbf{Switch} to the
\textbf{Controller} in response to a feature request packet from the
\textbf{Controller}. The feature request packet contains information about the
specifications of the \textbf{Switch} such as the number of tables it has and
the size of the buffer. The buffer size and number of tables currently have no
use and is only included as it was a part of the OpenFlow specification. The
feature result packet also contains the \textbf{Switch's} name and its
connections. The switch connections are used when calculating the path to the
specified destination.

\subsubsection{FlowModPacketContent}
This class is used to create a packet which represents a flow mod packet. The
flow mod packet is sent by the \textbf{Controller} to a \textbf{Switch}. The
flow mod packet is used to change a \textbf{Switch's} flow table. The flow mod
packet contains two strings, the destination and the next hop. Upon receiving a
flow mod packet, the \textbf{Switch} update it's flow table with the destination
as the key and the next hop as the value.

\subsubsection{HelloPacketContent}
This class is used to create a packet which represents a hello packet. The hello
packet is sent by both the \textbf{Switch} and \textbf{Controller}. The hello
packet contains the version number. When receiving a hello packet, the lower
version of the protocol is set. In my assignment, the default version number
is set to 1. In my version of OpenFlow, the hello packet is sent first by the
\textbf{Switch} to the \textbf{Controller} upon initialisation. The
\textbf{Controller} then responds with it's own hello packet back to the
\textbf{Switch}. This differs from the actual OpenFlow specification as the
hello packet should be asynchronous.

\subsubsection{PacketInPacketContent}
This class is used to create a packet which represents a packet in packet. The
packet in packet is sent by the \textbf{Switch} to the \textbf{Controller}.
This packet is used to ask the \textbf{Controller} for a flow mod packet. This
packet is sent in the case where a table miss occurs and the switch does not
know where to forward the packet. The packet in packet contains the final
destination of the packet and the switch name. The destination and the switch
name are both keys in the \textbf{Controller's} flow tables.

\subsubsection{PayloadPacketContent}
This class is used to create a packet which represents a payload packet. The
payload packet contains the payload i.e. the string containing the message and
final destination of the packet. This packet is sent by the \textbf{EndNodes}
as well as the \textbf{Switches}. This packet is the packet which is forwarded
from \textbf{Switch} to \textbf{Switch} and to the final destination
\textbf{EndNode}.

\subsection{Node Classes}
This section includes a description of each of the nodes classes which are
interfaced by the terminal. They represent any type of node in the network.

\subsubsection{Controller}
The \textbf{Controller} is used to direct the \textbf{Switches} when they have
no flow table entry for a packet. The \textbf{Controller} sends a flow mod
packet upon receiving a packet in packet. The paths are stored in a hash table.
They key is a string which is the final destination the packet to be forwarded.
The value is another hash table of which the key is the switch. The value is the
next hop the switch has to forward the packet to.

The \textbf{Controller} used to contain a predefined path. However I have since
changed it to use Link State Routing. The \textbf{Controller} uses the Graph
class in order to calculate a path to the destination. If the destination is not
in the hash table, the path is calculated and is then stored into the hash table.
The path is only generated when a \textbf{Switch} requests for the next hop and
the destination is not found in the flow table. If no path is found, the
\textbf{Controller} sends an unknown destination packet to the \textbf{Switch}.

\subsubsection{EndNode}
The \textbf{EndNode} is where the user can send and receive messages. The user
is able to choose another \textbf{EndNode} to send the message to. The message
it takes in is of type string and is encapsulated in a payload packet. This
payload packet is sent to a \textbf{Switch} which is then forwarded to another
\textbf{Switch} or to the destination \textbf{EndNode}. When an \textbf{EndNode}
receives a payload packet, the message is printed out to the terminal.

The \textbf{EndNode} implements a command system. This command system contains
the commands ``help'', ``clear'' and ``message send
\textless`message'\textgreater
\textless{}destin-\newline{}ation\textgreater{}''. The ``help'' command is used
to display all the commands available. The ``clear'' command is used to clear the
terminal screen and the ``message send'' command is used to send a string
message to the destination \textbf{EndNode}.

\subsubsection{Node}
This class is an abstract class which all of the \textbf{Node} classes inherit.
This class has been provided to us from the advanced sample code. It has been
modified slightly in the previous assignment, the changes of which is carried
through to this assignment.

\subsubsection{Switch}
The \textbf{Switch} class uses a hash table to store the payload packet's next
hop. When the \textbf{Switch} receives a payload packet, the destination is
looked up in the hash table. If the destination in the hash table exists, the
packet is then forwarded to the next hop. If the destination does not exist,
then the \textbf{Switch} sends a packet in packet to the \textbf{Controller}.
A countdown latch is used to wait for a flow mod packet to arrive. Upon the
arrival of a flow mod packet, the payload packet is then forwarded to the
next hop.

A queue called the packet buffer is used to deal with payload packet arrivals.
This allows the payload packets to be handled one at a time and asynchronously.
An infinite loop is used to process the payload packets in a thread.

\subsection{Path Finding class}
This path finding class is used to implement the link state routing. It
implements the algorithm which computes the path to the destination.

\subsubsection{Graph}
The graph class contains a node class. This node class represents nodes in the
network in a graph. The node class contains the name of the node as well as the
node's adjacent nodes. This abstract data structure is used when calculating the
path to the destination.

All of the nodes are stored in the graph's hash table. The key of the hash
table is a string which is the name of the node. The value of the hash table is
the reference to the node which has that name.

I found it difficult to measure the latency between the connections in docker
and thus was unable to obtain the weights of the edges in the graph. I used a
breadth first search algorithm instead of Dijkstra's algorithm for this reason.

\subsection{Miscellaneous Classes}
This section contains an explanation of the classes which did not fit into the
other categories.

\subsubsection{Terminal}
The terminal class was provided to us in the sample code. I have slightly
modified the terminal class to have the ability to clear the terminal screen
as well as read a boolean from the user. The boolean function was implemented
using JOptionPane to display a yes or no question. The boolean function however
was not used in this assignment but was used in the first assignment.

\subsubsection{Tokenizer}
The tokenizer class was used to split up the command into tokens and has the
ability to separate messages in quotations. This was created instead of using
the string split function as it allows the message sent to have spaces instead
of being a single word.

\section{Advantages and Disadvantages}
\subsection{Advantages}
\begin{itemize}
  \item{Implements Link State Routing thus allowing any valid switch and
    endpoint connection combinations to be used.}
  \item{Does not allow the use of multiple \textbf{Controllers}.}
  \item{It is asynchronous due to the use of threads.}
  \item{The implementation is abstracted well using Java's object orientated
    nature and the use of classes.}
\end{itemize}
\subsection{Disadvantages}
\begin{itemize}
  \item{Does not deal with invalid or unconnected graphs.}
  \item{Is not an accurate implementation of the OpenFlow specification.}
  \item{Does not implement acknowledgements.}
  \item{Command system may be confusing to the user.}
  \item{Certain network configurations may cause the path to be calculated
    multiple times.}
\end{itemize}

\section{Program Usage}
The following are some instructions to run the project:
\begin{itemize}
  \item{This program was built around the use of Docker.}
  \item{To run the program, the bash script ``start\_sample\_route.sh'',
    ``start\_sam-\\ple\_route2.sh'' or the ``start\_straight\_line.sh'' may be
  used.}
  \item{The script must be run with root due to the nature of Docker and it's
    permissions required to run.}
  \item{The script ``start\_sample\_route2.sh'' may take an integer parameter
    to indicate the number of switches between the endpoints e.g. ``sudo
  start\_sam-\\ple\_route2.sh 3'' to have three switches between the endpoints.}
\end{itemize}

The program has only been tested on a Linux system and is not guaranteed to run
on a Windows or Mac machine.

\section{Reflection}

\end{document}
